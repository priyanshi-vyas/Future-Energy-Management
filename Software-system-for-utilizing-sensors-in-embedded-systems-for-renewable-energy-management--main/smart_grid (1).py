# -*- coding: utf-8 -*-
"""Untitled26.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jlm9zd0VeJh38E0bSG62U61TqMPr_mNR
"""

import random
import requests
import sys
import time
import logging
import unittest
import numpy as np
import pandas as pd
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import PolynomialFeatures
from sklearn.pipeline import make_pipeline
import matplotlib.pyplot as plt
from sklearn.ensemble import RandomForestRegressor

# Carbon emission factors for different energy sources (in metric tons of CO2 per TWh)
CARBON_EMISSION_FACTORS = {
    'Solar': 0.05,
    'Wind': 0.04,
    'Hydro': 0.1,
    'Other': 0.25,
    'Coal': 0.85
}

# Weather codes mappings
weather_conditions = {
    0: "Clear sky",
    1: "Mainly clear, partly cloudy, and overcast",
    2: "Low-level clouds",
    3: "Mid-level clouds",
    45: "Fog and depositing rime fog",
    48: "Depositing rime fog",
    51: "Light drizzle",
    53: "Moderate drizzle",
    55: "Dense drizzle",
    56: "Light freezing drizzle",
    57: "Dense freezing drizzle",
    61: "Slight rain",
    63: "Moderate rain",
    65: "Heavy rain",
    66: "Light freezing rain",
    67: "Heavy freezing rain",
    71: "Slight snow fall",
    73: "Moderate snow fall",
    75: "Heavy snow fall",
    77: "Snow grains",
    80: "Slight rain showers",
    81: "Moderate rain showers",
    82: "Violent rain showers",
    85: "Slight snow showers",
    86: "Heavy snow showers",
    95: "Thunderstorm",
    96: "Thunderstorm with slight hail",
    99: "Thunderstorm with heavy hail",
}

# API link
api_url = "https://api.open-meteo.com/v1/forecast?latitude={lat}&longitude={lon}&current_weather=true"


# class for System Monitoring
class SystemMonitor:
    def __init__(self):
        self.logs = []

    def log(self, message):
        self.logs.append(f"{time.strftime('%Y-%m-%d %H:%M:%S')} - {message}")
        print(self.logs[-1])  # For demonstration purposes, we print the log

    def get_logs(self):
        return self.logs

# Sensor classes
class Sensor:
    def __init__(self, sensor_type):
        self.sensor_type = sensor_type

    def get_real_time_data(self):
        return random.randint(80, 120)  # Simulated energy value

# Renewable sensors
class SolarSensor(Sensor):
    def get_adapted_data(self, weather_condition):
        if weather_condition == 'sunny':
            return self.get_real_time_data() * 1.5
        return self.get_real_time_data()

class WindSensor(Sensor):
    def get_adapted_data(self, weather_condition):
        if weather_condition == 'windy':
            return self.get_real_time_data() * 1.3
        return self.get_real_time_data()

class HydroSensor(Sensor):
    def get_adapted_data(self, weather_condition):
        if weather_condition in ['rainy', 'stormy']:
            return self.get_real_time_data() * 1.2
        return self.get_real_time_data()

class OtherSensor(Sensor):
    def get_adapted_data(self, weather_condition):
        return self.get_real_time_data()  # Constant output irrespective of weather

# Non-Renewable Sensor Class
class NonRenewableSensor(Sensor):
    def get_adapted_data(self, weather_condition):
        return self.get_real_time_data()

# Energy Management System
class EnergyManagementSystem:
    def __init__(self):
        self.renewable_sensor = None
        self.non_renewable_sensor = None

    def set_sensors(self, renewable_sensor, non_renewable_sensor):
        self.renewable_sensor = renewable_sensor
        self.non_renewable_sensor = non_renewable_sensor

    def analyze_energy_data(self, weather_condition):
        renewable_energy = self.renewable_sensor.get_adapted_data(weather_condition) if self.renewable_sensor else 0
        non_renewable_energy = self.non_renewable_sensor.get_adapted_data(weather_condition) if self.non_renewable_sensor else 0
        self.calculate_emission_savings(renewable_energy, non_renewable_energy)

        # Print the sensor types being used
        if self.renewable_sensor:
            print(f"Renewable Sensor Type: {self.renewable_sensor.sensor_type}")
        if self.non_renewable_sensor:
            print(f"Non-Renewable Sensor Type: {self.non_renewable_sensor.sensor_type}")

    def calculate_emission_savings(self, renewable_energy, non_renewable_energy):
        renewable_emission_factor = CARBON_EMISSION_FACTORS.get(self.renewable_sensor.sensor_type.split()[0], 1)
        non_renewable_emission_factor = CARBON_EMISSION_FACTORS.get(self.non_renewable_sensor.sensor_type.split()[0], 1)
        renewable_emissions = renewable_energy * renewable_emission_factor
        non_renewable_emissions = non_renewable_energy * non_renewable_emission_factor

        print(f"Renewable emissions: {renewable_emissions} metric tons of CO2")
        print(f"Non-renewable emissions: {non_renewable_emissions} metric tons of CO2")

    def calculate_total_energy(self, weather_condition):
        # Calculate total energy generated by both renewable and non-renewable sensors
        renewable_energy = self.renewable_sensor.get_adapted_data(weather_condition) if self.renewable_sensor else 0
        non_renewable_energy = self.non_renewable_sensor.get_adapted_data(weather_condition) if self.non_renewable_sensor else 0
        return renewable_energy + non_renewable_energy

    def compare_emissions(self, renewable_energy, non_renewable_energy):
        # Calculate emissions from renewable and non-renewable sources
        renewable_emission_factor = CARBON_EMISSION_FACTORS.get(self.renewable_sensor.sensor_type.split()[0], 1)
        non_renewable_emission_factor = CARBON_EMISSION_FACTORS.get(self.non_renewable_sensor.sensor_type.split()[0], 1)

        renewable_emissions = renewable_energy * renewable_emission_factor
        non_renewable_emissions = non_renewable_energy * non_renewable_emission_factor

        # Calculate potential emission reduction
        emission_reduction = non_renewable_emissions - renewable_emissions

        print(f"Potential CO2 Emission Reduction: {emission_reduction} metric tons")

        return emission_reduction

class BatteryStorage:

    def __init__(self, capacity, aux_capacity):
        self.capacity = capacity  # Maximum main battery storage capacity
        self.aux_capacity = aux_capacity  # Maximum auxiliary storage capacity
        self.stored_energy = 0    # Current energy in main battery storage
        self.auxiliary_storage = 0  # Current energy in auxiliary storage

    def store_energy(self, energy):
        if self.is_full():
            self.alert_storage_full()
            return

        # Storing energy in the main battery storage
        potential_energy = self.stored_energy + energy
        if potential_energy <= self.capacity:
            self.stored_energy = potential_energy
        else:
            # Redirecting excess energy to auxiliary storage
            excess_energy = potential_energy - self.capacity
            self.stored_energy = self.capacity
            self.redirect_to_auxiliary(excess_energy)

    def redirect_to_auxiliary(self, excess_energy):
        print(f"Redirecting {excess_energy} units of excess energy to auxiliary storage.")
        potential_aux_energy = self.auxiliary_storage + excess_energy
        if potential_aux_energy <= self.aux_capacity:
            self.auxiliary_storage = potential_aux_energy
            print()
        else:
            print("Auxiliary storage is also full. Halting excess energy storage.")
            self.auxiliary_storage = self.aux_capacity  # Fill the auxiliary storage completely

    def is_full(self):
        return self.stored_energy >= self.capacity and self.auxiliary_storage >= self.aux_capacity

    def release_energy(self, energy_needed):
        # Release energy from the battery, respecting its current storage
        energy_released = min(self.stored_energy, energy_needed)
        self.stored_energy -= energy_released
        return energy_released

    def check_storage_status(self):
        if self.stored_energy > self.capacity:
            print("Warning: Battery is overcharged. Adjusting storage levels.")
            self.adjust_storage_levels()

    def adjust_storage_levels(self):
        excess_energy = self.stored_energy - self.capacity
        self.stored_energy = self.capacity
        self.redirect_to_auxiliary(excess_energy)

    def check_safety(self):
        if self.stored_energy > self.capacity * 1.1:  # Overcharge check
            logging.error("Danger: Battery overcharged!")
            sys.exit("Emergency Shutdown: Battery Overcharge")

        if self.stored_energy < 0:  # Deep discharge check
            logging.error("Danger: Battery deep discharged!")
            sys.exit("Emergency Shutdown: Battery Deep Discharge")

class SmartGridController:
    def __init__(self, energy_system, battery_storage):
        self.energy_system = energy_system
        self.battery_storage = battery_storage

    def manage_energy_flow(self, demand, weather_condition):
        generated_energy = self.energy_system.calculate_total_energy(weather_condition)
        energy_deficit = demand - generated_energy

        if energy_deficit > 0:
            energy_from_battery = self.battery_storage.release_energy(energy_deficit)
        else:
            excess_energy = -energy_deficit
            if not self.battery_storage.is_full():
                self.battery_storage.store_energy(excess_energy)
            else:
                print("Warning: Energy storage halted as all storages are full.")

        self.battery_storage.check_storage_status()

        print(f"Remaining battery storage: {self.battery_storage.stored_energy} units")
        print(f"Energy in auxiliary storage: {self.battery_storage.auxiliary_storage} units")

class FutureEmissionPredictor:
    def __init__(self, current_year, final_year, current_emission_reduction):
        self.current_year = current_year
        self.final_year = final_year
        self.current_emission_reduction = current_emission_reduction

    def predict_future_savings(self, degree=3):
        years = np.array([self.current_year, self.final_year]).reshape(-1, 1)
        savings = np.array([self.current_emission_reduction, self.current_emission_reduction * 1.05])
        polynomial_model = make_pipeline(PolynomialFeatures(degree), LinearRegression())
        polynomial_model.fit(years, savings)
        future_years = np.arange(self.current_year, self.final_year + 1).reshape(-1, 1)
        return future_years.flatten(), polynomial_model.predict(future_years)

# Function to get weather data
def get_weather_data(latitude, longitude):

    final_url = api_url.format(lat=latitude, lon=longitude)

    try:
        response = requests.get(final_url)
        response.raise_for_status()

        data = response.json()

        weather_code = data['current_weather']['weathercode']
        weather_condition = weather_conditions[weather_code]
        print(f"Current weather condition: {weather_condition}")

        return data['current_weather']

    except requests.exceptions.HTTPError as err:
        print(f"Error getting weather data: {err}")
        sys.exit(1)

    if 'current_weather' not in data:
        logging.error("Weather data is not available.")
        sys.exit("Failed to retrieve weather data.")

    return data['current_weather']

# Main execution
def main():

    # Initialize System Monitor
    monitor = SystemMonitor()
    monitor.log("System started")

    print("Weather Information")
    print("-------------------")
    latitude = float(input("Enter latitude: "))
    longitude = float(input("Enter longitude: "))

    weather_data = get_weather_data(latitude, longitude)
    energy_system = EnergyManagementSystem()

    weather_code = weather_data['weathercode']
    weather = weather_conditions[weather_code]

    # Choose and set the appropriate sensor
    if weather in ["Clear sky", "Mainly clear, partly cloudy"]:
        energy_system.set_sensors(SolarSensor("Solar"), NonRenewableSensor("Coal"))
    elif weather == "Windy":
        energy_system.set_sensors(WindSensor("Wind"), NonRenewableSensor("Coal"))
    elif weather in ["Rainy", "Stormy"]:
        energy_system.set_sensors(HydroSensor("Hydro"), NonRenewableSensor("Coal"))
    else:
        energy_system.set_sensors(OtherSensor("Other"), NonRenewableSensor("Coal"))

    battery_capacity = 200  # Example capacity
    aux_capacity = 100
    battery_storage = BatteryStorage(battery_capacity, aux_capacity)
    smart_grid_controller = SmartGridController(energy_system, battery_storage)

    energy_demand = 100  # Example demand

    # Timing mechanism for synchronous model
    fetch_interval = 10  # Interval in seconds for each synchronous tick
    duration = 60  # Duration in seconds for the synchronous loop to run
    number_of_ticks = duration // fetch_interval  # Calculate how many ticks will occur

    for tick in range(number_of_ticks):
        print(f"Tick {tick + 1}/{number_of_ticks}")
        # Simulate real-time energy data analysis
        energy_system.analyze_energy_data(weather)
        # Manage energy flow based on the current demand and weather
        smart_grid_controller.manage_energy_flow(energy_demand, weather)

        battery_storage.check_safety()  # Check battery safety

        time.sleep(fetch_interval)


    # Simulate real-time energy data analysis and emission comparison
    energy_system.analyze_energy_data(weather_conditions)
    emission_reduction = energy_system.compare_emissions(
        energy_system.renewable_sensor.get_adapted_data(weather_conditions),
        energy_system.non_renewable_sensor.get_adapted_data(weather_conditions)
    )

    # Future Emission Prediction and Visualization
    current_year = 2023
    final_year = 2050
    current_emission_reduction = emission_reduction  # From the previous part of the code
    predictor = FutureEmissionPredictor(current_year, final_year, current_emission_reduction)
    future_years, predicted_savings = predictor.predict_future_savings()

    # Display the predicted CO2 emission savings
    for year, saving in zip(future_years, predicted_savings):
        print(f"Year: {year}, Predicted CO2 Emission Saving: {saving:.2f} metric tons")

    # Visualization of the predicted savings
    plt.figure(figsize=(12, 6))
    plt.plot(future_years, predicted_savings, 'b-', label='Predicted CO2 Savings')
    plt.title('Predicted CO2 Emission Savings from Renewable Energy (2023-2050)')
    plt.xlabel('Year')
    plt.ylabel('CO2 Savings (Metric Tons)')
    plt.legend()
    plt.show()

    monitor.log("System shutdown")


#Automated Testing Suite
class TestEnergySystem(unittest.TestCase):
    def setUp(self):
        self.solar_sensor = SolarSensor("Solar")
        self.non_renewable_sensor = NonRenewableSensor("Coal")
        self.energy_system = EnergyManagementSystem()
        self.energy_system.set_sensors(self.solar_sensor, self.non_renewable_sensor)

    def test_sensor_data(self):
        self.assertIsInstance(self.solar_sensor.get_real_time_data(), int)
        self.assertIsInstance(self.non_renewable_sensor.get_real_time_data(), int)

    def test_emission_calculation(self):
        self.energy_system.analyze_energy_data("sunny")
        self.assertGreaterEqual(self.energy_system.calculate_total_energy("sunny"), 0)

    def test_compliance_check(self):
        self.energy_system.check_compliance()

if __name__ == "__main__":
    main()
